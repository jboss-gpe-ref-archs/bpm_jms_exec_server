:data-uri:
:toc2:
:rpms: link:https://github.com/jboss-gpe-ose/jboss_bpm_soa_rpmbuild[RPMs]
:cart: link:https://github.com/jboss-gpe-ose/openshift-origin-cartridge-bpms-full[Red Hat GPE's BPM Suite 6 cartridge]
:bpmproduct: link:https://access.redhat.com/site/documentation/en-US/Red_Hat_JBoss_BPM_Suite/[Red Hat's BPM Suite 6 product]
:osetools: link:https://access.redhat.com/site/documentation/en-US/OpenShift_Enterprise/2/html-single/Client_Tools_Installation_Guide/index.html[Openshift Enterprise client tools]
:commands: link:https://access.redhat.com/site/documentation/en-US/Red_Hat_JBoss_BPM_Suite/6.0/html-single/Development_Guide/index.html#Execute_calls[BPM Suite 6 Commands]

image::images/rhheader.png[width=900]

:numbered!:
[abstract]
== BPM Suite 6 Execution Server:  JMS API
This reference architecture provides a detailed example of how to configure and use the JMS API of the BPM Suite 6 Execution Server.
Along with the explanation, a project is provided with instructions on how to execute the example.

This reference architecture provides two major use cases related to JMS and BPM Suite 6 and one utility use case.  The two major use case are the following:

. `JMS Transport` - Starting a BPM Suite 6 process via a JMS transport.  The use case includes passing parameters to the BPM Suite 6 process and receiving a confirmation response from BPM Suite 6.
. `JMS Service Task` - Sending a JMS message from a BPM Suite 6 process.

The utility use case uses JMeter to perform load tests against the JMS transport.  The term `utility use case` is used because it is not functionality that to be used in an application, yet it provides vital information for building applications.  

The following discusses when it is necessary to use these use cases, how the examples work, and how to configure the examples to run on your own system.

TIP: Within the context of the discussion, `TIP` sections like this will be used to highlight best practices.

:numbered:

== BPM Suite 6 integration via JMS
Message queues are a vital component to many application architectures.  Any time two independent systems are required to communicate, there is the high potential
that they will differ in processing speed and availability.  This leads to the need for asynchronous communication to decouple the sender from the receiver.  This decoupling
has numerous benefits to the overall system including:

. *Decoupling* - The two systems can be extended and modified independently as long as they adhere to the same interface requirements
. *Redundancy* - The message may be held safely in the queue until the receiver is able to process the message without errors.
. *Scalability* - 
. *Resiliency* -
. *Delivery Guarantees* - 
. *Ordering Guarantees* - 
. *Buffering* - 

The JMS API can be used in two directions with respect to BPM Suite 6. First a JMS message may be sent to the BPM Suite 6 server to start a process.  Second
a BPM Suite 6 process may need to send a JMS message to a topic or queue.  Both of these cases are are addressed in this reference architecture.

== The JMS Transport
The JMS transport example sends a POJO java object from a client application to a BPM Suite 6 process.  The BPM Suite 6 process is started upon retrieving the message from the JMS queue.  
For this example, a `client application` refers to process running outside of the JVM for the server.  
See the following diagram for an illustration of this use case.

The following architecture diagram illustrates the components discussed below.

.JMS Transport Architecture Diagram
image::images/jms_transport_arch_diagram.png[width="60%"]

Each component in the diagram plays a role in the execution of the use case and is discussed roughly in the order of execution of the use case.

=== Client JVM


=== JMS Client


=== pom.xml


=== Domain


=== HornetQ


=== Maven Repository


=== Execution Server


=== BPM Suite 6 Process Engine

== Pre-Requisites
The remainder of this documentation provides instructions for installation, configuration and execution of this reference architecture.  
The following is a list of pre-requisites:

. {osetools}
. Openshift Enterprise 2.* environment that has been installed with {rpms} needed to support {cart}.  Contact the Red Hat GPE team for more details.
. medium-sized Openshift Enterprise gear provisioned with {cart} and mysql-5.
. ssh client
. maven 3.0.5 (or greater)
. git client
. familiarity with {bpmproduct}
. proficiency with basic *nix command line
. proficiency with vi

As is evidenced by these pre-requisites, the assumed BPM Suite 6 runtime environment for this reference architecture 
documentation is an Openshift Enterprise gear.  However, BPM Suite 6 can be installed in a non-PaaS local environment.  
Thus it could be possible to execute this reference architecture in a non-PaaS local environment as well.

== Configuration and Execution
To setup this use case we will take the following major steps:

.Setup Summary
. Clone this reference architecture
. Domain class installation
. Understand BPM Suite 6 message queues
. Configure port forwarding for the JMS Broker
. Add the target business process to the server
. Add the _JmsServiceQueue_
. Configure the JMS Client
. Execute the use case

The details of these steps are provided below.

=== Clone this reference architecture
This reference architecture will be cloned both in your local computer as well as in your remote BPM Suite 6 Openshift environment.  
To clone this reference architecture in your local environment, execute the following:  

-----
git clone https://github.com/jboss-gpe-ref-archs/bpm_jms_exec_server.git
-----

Doing so will create a directory in your local computer called:  _bpm_jms_exec_server_.  
For the purposes of the remainder of this reference architecture, this directory will be referred to as _$REF_ARCH_HOME_.

=== Domain class installation
In $REF_ARCH_HOME, there is a directory called `domain`.  
This directory contains a maven project for building and packaging the jar files that will contain the domain classes for this reference architecture.  
If you examine the domain classes, you will find that they are configured to enable serialization via Java Architecture for XML Binding (JAXB).  
There are steps required by the client to enable the server to process the JAXB annotated objects.
Those details are discussed in the <<Configure_the_JMS_Client,client configuration>> section. 

The following steps are directions for building the jar file and installing the jar as a static module on your EAP server running in OpenShift. Finally, we will also
configure the `business-central.war` application in BPM Suite 6 to have a dependency on the static module, making the domain class available to use in your business processes.

From your local cloned copy of this reference architecture execute the following:

. create the jar for the domain classes
.. `cd $REF_ARCH_HOME`
.. `mvn clean install`
. copy the directories and files required to create a static module on the JBoss EAP server
.. `scp -r domain/conf/org <your_openshift_url>:~/app-root/data/appModules/`
.. `scp domain/target/domain-1.0.jar <your_openshift_url>:~/app-root/data/appModules/org/acme/insurance/main`
. Add an explicit dependency for business-central.war on the static module for the domain module
.. `ssh <ssh_url_to_your_openshift_environment>`
.. Open the following file using vi:  `~/bpms/standalone/deployments/business-central.war/WEB-INF/jboss-deployment-structure.xml`
.. Add the following to the list of dependencies: 

-----
<module name="org.acme.insurance" export="true" services="import" meta-inf="import"/>
-----

.. Save the changes to the file
. Restart your OpenShift BPM Suite 6 instance
.. Determine if the JBoss process is already running by entering: `ps -aef | grep java`
... If the JBoss process is not running, then execute: `ctl_app start`
... If the JBoss process is running, then execute: `ctl_app restart` and select option `1` at the following prompt:

----------
Cart to restart?
1. bpms-6.0
2. mysql-5.1
----------

When the cursor returns, typically the server has not completely started at that moment.  Use the following command to view the log file and confirm
when the server startup has completed:

.View the server log
----------
tail -f ~/bpms/standalone/log/server.log
----------

Wait for a log entry that includes the following:

.Confirmation of server startup
----------
Deployed "business-central.war" (runtime-name : "business-central.war")
----------

Alternatively, you may get the following message:

.Start up confirmation message 2
----------
Replaced deployment "business-central.war" with deployment "business-central.war"
----------



=== Understand BPM Suite 6 Message Queues
When the business-central Workbench is deployed, the embedded _Execution Server_ begins to listen on the following queues already configured in the Hornetq subsystem:

* jms/queue/KIE.SESSION
* jms/queue/KIE.TASK
* jms/queue/KIE.RESPONSE

The `KIE.SESSION` and `KIE.TASK` queues should be used to send command request messages to the JMS API. 
Command response messages will be then placed on the `KIE.RESPONSE` queue. 
Command request messages that involve starting and managing business processes should be sent to the `KIE.SESSION` and command request messages that involve managing human tasks, should be sent to the `KIE.TASK` queue.

Messages sent to the two different input queues, `KIE.SESSION` and `KIE.TASK`, will be processed in the same manner regardless of which queue they are sent to.  The reason that two input queues are provided (rather than just one) is to allow for prioritization.  
For example, in some use-cases, clients may send many more requests involving human tasks than requests involving business processes.  
If the business-process related messages are sent to `KIE.SESSION` and the human-task related messages are sent to `KIE.TASK`, then processing of business-process related messages occurs independent of processing of human-task related messages.

The BPM Suite 6 Execution Server uses a Message Driven Bean (MDB) to process messages from the queues.  
To change any of the above queues to an alternative queue, change the JDNI name in the MDB configuration to point to the desired queue.  
The JNDI configuration for the MDB can be found at the following location:

.ejb-jar.xml file for the MDB
----------
$JBOSS_HOME/standalone/deployments/business-central.war/WEB-INF/ejb-jar.xml
----------

In your remote Openshift environment provisioned with BPM Suite 6, the three business-central queues are already created in the default messaging subsystem: HornetQ. 
To view them, open your browser to the JBoss EAP management console of your remote Openshift environment and navigate to:  Profile -> Subsystems -> Messaging -> Destinations -> default .  
The following should appear:

image::images/queues.png[]

Also, enabled by default in your remote Openshift environment is the messaging configuration: _message-counter-enabled_.  
This will prove useful later when executing the included load test to easily visualize real-time messaging statistics per queue.  
The overhead of enabling messaging statistics in HornetQ is negligible.

By default, authentication to the Hornetq messaging subsystem is enabled in JBoss EAP 6.  
Also, authorization rules are set to restrict only authenticated users with a role of _admin_ the ability to send messages to the BPM Suite 6 queues.  
These messaging security settings can be seen by navigating to the following the JBoss EAP management console of your Openshift environment:  Profile -> Subsystems -> Messaging -> Destinations -> default -> Security Settings.

image::images/messaging_security.png[]

The remote Openshift environment provisioned with JBoss EAP and BPM Suite 6 has already been pre-configured to allow for the _jboss_ user to send messages to the BPM Suite 6 queues.  
Therefore, your JMS clients sending process-instance and human task related messages to the BPM Suite 6 JMS API should do so as the 'jboss' user. 

HornetQ uses port `5445` which is not an open port on the OpenShift server.
Therefore port forwarding is configured in the next step to resolve this issue.

[[HornetQ_port_forwarding]]
=== Configure port forwarding for the JMS Broker
The ssh utility allows you to forward a port through the encrypted connection it establishes.  This setup is also referred to as `ssh tunneling`.
Since port 5445 is not open on the OpenShift server, port forwarding will be configured to securely access these services.

Execute the following commands from your command window on your local computer to configure and launch a port forwarding process for access to HornetQ:

.Obtain the IP address for the OSE internal NIC
----------
ssh <ssh_url_to_your_openshift_environment> 'echo $OPENSHIFT_BPMS_IP'
----------

.Port Forwarding command for HornetQ access
----------
ssh -N -L localhost:5445:<ipaddress from previous step>:5445 <ssh_url_to_your_openshift_environment>
----------

While the port forwarding process is running, the HornetQ broker can be accessed on the local computer at `localhost:5445`.
Use `Ctrl+c` to kill port forwarding.

=== Add the target business process to the server
This reference architecture uses a simple buiness process that prints a confirmation message that indicates that the process instance was started and that the parameter sent via the JMS message is available to the business process as a process variable.

To setup the business process, setup the repository on BPM Suite 6, make a local clone, add the project to your clone, then use a git push to update the remote BPM Suite 6 server.
The following provides the details for these steps.

Use the following steps to setup the business process for this reference architecture:

. Create an *Organization and clone this project's git repository in your BPM Suite 6 server
.. Select `Authoring` -> `Administration`
.. Select `Organizational Units` -> `Manage Organizational Units`
.. Under `Organizational Unit Manager`, select the `Add` button
.. Enter a name of _gpe_ and an owner of _jboss_. Click `Ok`
.. Select `Repostories` -> `New Repository` .  Populate the _Clone Repository_ box as follows and then click _Clone_ :

image::images/clone_repo.png[]

The _Git URL_ is the URL to this git project in github:  _https://github.com/jboss-gpe-ref-archs/bpm_jms_exec_server.git_ . Once successfully cloned, BPM Suite 6 will pop-up a new dialogue box with the message:  _The repository is cloned successfully_


. View the _processTier_ project in your BPM Suite 6 server
.. Select `Authoring` -> `Project Authoring `
.. Make sure the `processTier` repository is viewable in the `Project Explorer`
... Toggle the view using the wheel icon image:images/wheel.png[] if needed.


[start=2]
. Open a command window to your previously cloned $REF_ARCH_HOME/bpm_jms_exec_server directory.
. Add to this git project a remote reference to the corresponding _bpmjmsexecserver_ repository in your Openshift environment

----------
git clone ssh://<your.openshift.ssh.url>/~/app-root/data/bpmsGit/.niogit/bpmjmsexecserver.git
----------

. in your local $REF_ARCH_HOME/bpms_jms_exec_server directory, execute:  git pull remote master to sync your local repo with your remote Openshift repo.


[start=6]
. From within the business-central workbench, select `Authoring` -> `Project Authoring`
. Find and open the `bpm_jms_exec_server` BPMN2 business process in the Web Designer
. Open the `Properties` panel for the process and notice the process Id value of `processTier.bpm_jms_exec_server`. This will be used in the client's JMS message.

image::images/bpmn.png

Use the following steps to create a deployment for the project:

[start=9]
. From within the business-central workbench, select `Authoring` -> `Project Authoring`
. Select the `Build & Deploy` button.
. After the build completes, select `Deploy` -> `Deployments`
. Take note of the deployment Id in the column labeled `Deployment`.
.. If you used the values in this document, then the deployment ID will be `com.redhat.gpe.refarch.bpm_jms_exec_server:processTier:1.0`.  This value will be used in the client's JMS message.

=== Add the _JmsServiceQueue_
The *bpm_jms_exec_server* business process definition defines a custom Service Task whose corresponding custom workItemHandler will send a message to a business queue in the co-located Hornetq sub-system.  
This business queue (called _JmsServiceQueue_ ) needs to be created in the Hornetq subsystem.  
To create this queue, open the JBoss EAP Management Console to your remote Openshift environment and navigate to:  Profile -> Subsystems -> Messaging -> Destinations -> default -> Queues/Topics -> Add .  
Populate the dialogue box as follows:

image::images/add_queue.png[]

[[Configure_the_JMS_Client]]
=== Configure the JMS Client
The JMS Client is located in the *$REF_ARCH_HOME/loadTest* directory of this reference architecture.  It is a single java class that builds an instance of the domain object and
sends the object in a JMS Message to the BPM Suite 6 server to start a business process.  The name of the class is *com.redhat.gpe.refarch.bpm_jms_exec_server.JMSClient*

This document will not cover aspects of this client that are common to sending JMS messages,  However, there are a few important details in the client that are 
specific to this use case that require further explanation.  These details are discussed in the following sections.  Open the client class
in an editor to view the details along with this discussion.

==== JAXB deserialization
The client class uses JAXB to serialize the POJOs before sending them via JMS.  The following is required by the client to provide the JAXB context required for serializing
the POJO on the client side:

.Providing the JAXB context on the client
----------
/* -------  Required for proper serialization on the Client side (for the JAXB context) ------- */
jaxbSerializationProvider.addJaxbClasses(Policy.class);
----------

On the server side, these objects must be deserialized via JAXB.  For this to occur
the server must know the type of the object contained within the message.  To provide this information on the server, a special string property is is added to the
JMS message by the following code.
 
The following code snipped is from the `sendJMSJaxCommandsRequest` method of the class:

.Providing Context for JAXB Deserialization
----------
/* ----- Required for deserialization on the server ---------- */
Set<Class<?>> extraJaxbClasses = new HashSet<Class<?>>();
extraJaxbClasses.add(Policy.class);
String extraJaxbClassesPropertyValue = JaxbSerializationProvider.classSetToCommaSeperatedString(extraJaxbClasses);
msg.setStringProperty(EXTRA_JAXB_CLASSES_PROPERTY_NAME, extraJaxbClassesPropertyValue);
----------

In this code snipped, *Policy.class* is the class for the POJO object called Policy.  If additional classes were required, then simply add more calls to 
the `extraJaxbClasses.add` method.  

==== Provide the target for the message
Once the object has been deserialized on the server, the Execution Server must know which deployment is the target of the message.  For this information,
another string property is set on the JMS message as shown in the follow code snippet:

.Providing the DeploymentID
----------
/* ------- Required for the server to locate the target deployment for the process --------- */
msg.setStringProperty(DEPLOYMENT_ID_PROPERTY_NAME, deploymentId);
----------

The value for `deploymentId` is provided as a property in the *$REF_ARCH_HOME/loadtest/pom.xml* file, and initialized in the constructor for this class.

==== BPM Suite 6 command objects
The client use a BPM Suite 6 command objects to provides a programmatic interface to the JMS API and take care of the underlying details of sending and receiving commands via JMS.
The following code of the client is used to create the command object for starting a process in BPM Suite 6:

.StartProcess Command object
----------
// create the start process command object
StartProcessCommand cmd = new StartProcessCommand(processId); <1>
        
// populate domain model classes
Policy policyObj = populatePolicyObject();
cmd.putParameter(POLICY, policyObj);  <2>
        
// send the start process command
JaxbCommandsRequest req = new JaxbCommandsRequest(deploymentId, cmd); <3>
----------
<1> The *StartProcessCommand* object is created.  The `processId` of the target process is provided as parameter to the command.
<2> The call to *putParameter* on the command object is used to provide the payload.
<3> The StartProcessCommand object is then sent as parameter to the *JaxbCommandRequest* wrapper object.

The StartProcessCommand object is only one of may commands that can be processed by the execution server.  For a complete list of available commands
see {commands}.

=== Execute the use case
Before executing the test, open the *pom.xml* file and configure the parameters to suite your server.  In particular be sure that the following properties are correct for your environment:

* process.id
* deploymentId
* hornetq.host
* hornetq.user
* hornetq.password

To execute the process do the following:

. Open a command window and ssh into your server instance.
. Execute `tail -f ~/bpms/standalone/log/server.log` to watch the server log entry during the test
. If it is not already running, open a command windown and run port forwarding for HornetQ as described in <<HornetQ_port_forwarding,Configure port forwarding for the JMS Broker>>.
. Open a command window to the $REF_ARCH_HOME/loadTest directory and execute:  `mvn clean verify`

=== View results
* The server.log of your remote BPM Suite 6 enabled Openshift Environment should include statements similar to the following:

-------
[com.redhat.gpe.refarch.bpm_jms_exec_server.processTier.JMSWorkItemHandler]  Sending messageContent: Driver  properties =
    driverName : alex
    dlNumber : 7
    age : 21
    # accidents : 0
    # tickets : 1
    SSN : 555-55-555
    # creditScore : 800
-------

* Also, in the JBoss EAP Management Console, notice that JMS messages have begun to accumulate in the previously configured _JmsServiceQueue_ :

image::images/message_stats.png

==  JMS Service Task
The purpose of this custom Work Item Handler is to provide a flexible JMS Service for sending messages via JMS to a JMS Queue or Topic.
The following are setup details:

The following architecture diagram illustrates the components discussed below.

.JMS Service Task Architecture Diagram
image::images/JMS_WIH_arch_diagram.png[width="60%"]

Each component in the diagram plays a role in the execution of the use case and is discussed roughly in the order of execution of the use case.

=== Maven Repository


=== BPM Suite 6 Process Engine


=== JMS Service WIH


=== Domain


=== JMS Broker


== JMS Service Task use and configuration


=== Adding the registration for the WIH
To register the Work Item Handler it must be registered with the process engine.  This is done via the project kmodule.xml as follows:

. Within Business-central navigate to the `kmodule.xml` file. (under resources/META-INF)
. Notice the following has already been added:

----------
<kmodule xmlns="http://jboss.org/kie/6.0.0/kmodule" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <kbase name="policyQuoteKBase" default="true" eventProcessingMode="stream" equalsBehavior="equality" declarativeAgenda="disabled" scope="javax.enterprise.context.ApplicationScoped" packages="*">
    <ksession name="policyQuoteKSession" type="stateful" default="true" clockType="realtime" scope="javax.enterprise.context.ApplicationScoped">
      <workItemHandlers>
        <workItemHandler type="new org.gpe.service.jms.JMSWorkItemHandler()" name="JMSServiceTask"/>
      </workItemHandlers>
    </ksession>
  </kbase>
</kmodule>
----------

== Performance Testing
In the following we measure the system impact when changes are made to configuration paramenters on the JMS interface between BPM Suite 6 and 
JMS client applications.  Other relevant BPM Suite 6 configuration options are also taken into consideration.
* Queue sizing
* message listener configuration
* durable vs non-durable queues
* Single process knowledge session vs process per request
